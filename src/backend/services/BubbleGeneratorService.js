/**
 * BUBBLEVOICE MAC - BUBBLE GENERATOR SERVICE
 * 
 * Generates proactive "bubble" suggestions during conversations.
 * Bubbles are short (≤7 words) contextual prompts that help
 * continue the conversation naturally.
 * 
 * RESPONSIBILITIES:
 * - Generate contextual bubble suggestions
 * - Ensure bubbles are relevant to current conversation
 * - Limit bubble length (≤7 words)
 * - Avoid repetitive suggestions
 * 
 * PRODUCT CONTEXT:
 * Bubbles are a key differentiator for BubbleVoice. They make
 * conversations feel proactive and contextual, not just reactive.
 * Good bubbles reference specific personal context from past
 * conversations (e.g., "how's Emma doing?" not just "tell me more").
 * 
 * TECHNICAL NOTES:
 * - Bubbles are generated by the LLM alongside the main response
 * - This service provides utilities and validation
 * - Future: Could use a separate lightweight model for bubble generation
 */

class BubbleGeneratorService {
  constructor() {
    // Bubble configuration
    this.config = {
      maxLength: 7, // Maximum words per bubble
      minBubbles: 2,
      maxBubbles: 4
    };

    // Recent bubbles cache
    // Used to avoid repetition
    this.recentBubbles = new Map(); // conversationId -> Set of recent bubbles
  }

  /**
   * VALIDATE BUBBLES
   * 
   * Validates and filters bubble suggestions from LLM.
   * Ensures bubbles meet quality criteria.
   * 
   * @param {Array<string>} bubbles - Raw bubble suggestions
   * @param {string} conversationId - Conversation ID
   * @returns {Array<string>} Validated bubbles
   */
  validateBubbles(bubbles, conversationId) {
    if (!Array.isArray(bubbles)) {
      return [];
    }

    const validated = [];
    const recentBubbles = this.recentBubbles.get(conversationId) || new Set();

    for (const bubble of bubbles) {
      // Skip if not a string
      if (typeof bubble !== 'string') {
        continue;
      }

      // Trim whitespace
      const trimmed = bubble.trim();

      // Skip if empty
      if (!trimmed) {
        continue;
      }

      // Check length (≤7 words)
      const wordCount = trimmed.split(/\s+/).length;
      if (wordCount > this.config.maxLength) {
        console.warn(`[BubbleGeneratorService] Bubble too long (${wordCount} words): "${trimmed}"`);
        continue;
      }

      // Check for repetition
      if (recentBubbles.has(trimmed.toLowerCase())) {
        console.log(`[BubbleGeneratorService] Skipping repetitive bubble: "${trimmed}"`);
        continue;
      }

      // Validate format (should be a question or prompt)
      if (!this.isValidBubbleFormat(trimmed)) {
        console.warn(`[BubbleGeneratorService] Invalid bubble format: "${trimmed}"`);
        continue;
      }

      validated.push(trimmed);

      // Add to recent bubbles
      recentBubbles.add(trimmed.toLowerCase());
    }

    // Update recent bubbles cache
    this.recentBubbles.set(conversationId, recentBubbles);

    // Limit cache size (keep last 20 bubbles)
    if (recentBubbles.size > 20) {
      const toRemove = Array.from(recentBubbles).slice(0, recentBubbles.size - 20);
      toRemove.forEach(b => recentBubbles.delete(b));
    }

    // Ensure we have the right number of bubbles
    if (validated.length < this.config.minBubbles) {
      console.warn(`[BubbleGeneratorService] Too few bubbles (${validated.length}), adding generic ones`);
      validated.push(...this.getGenericBubbles(this.config.minBubbles - validated.length));
    }

    if (validated.length > this.config.maxBubbles) {
      return validated.slice(0, this.config.maxBubbles);
    }

    return validated;
  }

  /**
   * IS VALID BUBBLE FORMAT
   * 
   * Checks if a bubble has a valid format.
   * Valid bubbles are typically questions or short prompts.
   * 
   * @param {string} bubble - Bubble text
   * @returns {boolean} True if valid
   */
  isValidBubbleFormat(bubble) {
    // Should end with ? or be a short prompt
    if (bubble.endsWith('?')) {
      return true;
    }

    // Short prompts without punctuation are ok
    if (bubble.length < 30 && !bubble.endsWith('.')) {
      return true;
    }

    // Should not be a full sentence
    if (bubble.endsWith('.') && bubble.length > 40) {
      return false;
    }

    return true;
  }

  /**
   * GET GENERIC BUBBLES
   * 
   * Returns generic fallback bubbles when LLM doesn't generate enough.
   * These are safe, general prompts that work in most contexts.
   * 
   * @param {number} count - Number of bubbles needed
   * @returns {Array<string>} Generic bubbles
   */
  getGenericBubbles(count) {
    const generic = [
      'tell me more',
      'what else?',
      'how do you feel?',
      'what happened next?',
      'why is that?',
      'what are you thinking?'
    ];

    // Shuffle and return requested count
    const shuffled = generic.sort(() => Math.random() - 0.5);
    return shuffled.slice(0, count);
  }

  /**
   * CLEAR RECENT BUBBLES
   * 
   * Clears the recent bubbles cache for a conversation.
   * Used when starting a new conversation.
   * 
   * @param {string} conversationId - Conversation ID
   */
  clearRecentBubbles(conversationId) {
    this.recentBubbles.delete(conversationId);
  }

  /**
   * GENERATE CONTEXTUAL BUBBLES
   * 
   * Generates contextual bubbles based on conversation history.
   * This is a fallback method if LLM doesn't generate bubbles.
   * 
   * @param {Object} conversation - Conversation object
   * @returns {Array<string>} Generated bubbles
   */
  generateContextualBubbles(conversation) {
    // Simple heuristic-based bubble generation
    // In production, this would use a lightweight model or rules

    const bubbles = [];

    // Look at recent messages for context
    const recentMessages = conversation.messages.slice(-3);
    
    // Extract topics/entities (very simple approach)
    const topics = new Set();
    for (const msg of recentMessages) {
      // Look for capitalized words (potential names/topics)
      const words = msg.content.match(/\b[A-Z][a-z]+\b/g) || [];
      words.forEach(w => topics.add(w));
    }

    // Generate bubbles based on topics
    if (topics.size > 0) {
      const topicArray = Array.from(topics);
      bubbles.push(`more about ${topicArray[0]}?`);
      
      if (topicArray.length > 1) {
        bubbles.push(`what about ${topicArray[1]}?`);
      }
    }

    // Add generic bubbles to fill
    while (bubbles.length < this.config.minBubbles) {
      bubbles.push(...this.getGenericBubbles(1));
    }

    return bubbles.slice(0, this.config.maxBubbles);
  }
}

module.exports = BubbleGeneratorService;
